/*
 * Переносимая реализация БПФ для процессоров стандартной архитектуры
 * Версия: 0.2b
 * Файл: "fft.h"
 * Кодировка: UTF-8
 * Авторы: Дмитрий Сусляков, Александр Гриньков
 * Дата модификации: 2011.11.23
 */

#ifndef FFT_H
#define FFT_H
//----------------------------------------------------------------------------
// опция отладочной печати на stderr
#define FFT_DEBUG // FIXME
//----------------------------------------------------------------------------
#ifdef FFT_DEBUG
#  include <stdio.h> // fprintf()
#  ifdef FFT_WIN32
#    define FFT_DBG(fmt, ...) fprintf(stderr, "RK: " fmt "\n", __VA_ARGS__)
#  else
#    define FFT_DBG(fmt, arg...) fprintf(stderr, "RK: " fmt "\n", ## arg)
#  endif
#else
#  ifdef FFT_WIN32
#    define FFT_DBG(fmt, ...)
#  else
#    define FFT_DBG(fmt, arg...)
#  endif
#endif // FFT_DEBUG
//---------------------------------------------------------------------------
// inline macro
#ifndef FFT_INLINE
#  if __GNUC__
#    define FFT_INLINE static inline
#  else
#    define FFT_INLINE inline
#  endif
#endif // FFT_INLINE
//---------------------------------------------------------------------------
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
//----------------------------------------------------------------------------
// функция расчёта поворотных множителей для БПФ
void fft_make(
  int p,     // показатель двойки (например, для БПФ на 256 точек это 8)
  float *c); // результирующий массив поворотных множителей c[1 << p]
//----------------------------------------------------------------------------
// функция расчёта поворотных множителей для ОБПФ
void fft_make_reverse(
  int p,     // показатель двойки (например, для ОБПФ на 256 точек это 8)
  float *c); // результирующий массив поворотных множителей c[1 << p]
//----------------------------------------------------------------------------
// функция бинарной инверсии индекса
FFT_INLINE int fft_binary_inversion(
  int p, // показатель двойки (например, для БПФ на 256 точек это 8)
  int i) // исходный индекс [0, (1 << p) - 1]
{
  int j = 0;
  while (p-- > 0)
  {
    j <<= 1;
    j |= i & 1;
    i >>= 1;
  }
  return j;
}
//----------------------------------------------------------------------------
// функция прямого БПФ
void fft_calc(
  int p,           // показатель двойки (например, для БПФ на 256 точек это 8)
  const float *c,  // массив поворотных множителей БПФ
  const float *in, // входной массив
  float *out,      // выходной массив
  int norm);       // признак нормировки
//----------------------------------------------------------------------------
// функция обратного БПФ
FFT_INLINE void fft_calc_reverse(
  int p,           // показатель двойки (например, для БПФ на 256 точек это 8)
  const float *c,  // массив поворотных множителей ОБПФ
  const float *in, // входной массив
  float *out,      // выходной массив
  int norm)        // признак нормировки
{
  fft_calc(p, c, in, out, !norm); // БПФ
}
//----------------------------------------------------------------------------
// функция перестановки отсчётов спектра (что бы "0" в центре)
void fft_shift(
  int p,        // показатель двойки (например, для БПФ на 256 точек это 8)
  float *data); // массив после БПФ
//----------------------------------------------------------------------------
#ifdef __cplusplus
}
#endif // __cplusplus
//----------------------------------------------------------------------------
#endif // FFT_H

/*** end of "fft.h" file ***/
